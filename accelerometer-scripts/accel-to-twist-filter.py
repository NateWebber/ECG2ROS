from time import sleep
import rclpy
from rclpy.node import Node
from polar2ros_interfaces.msg import Accelerometer
from geometry_msgs.msg import Twist

"""
This version of accel-to-twist attempts to only use accelerometer samples generated by a person walking,
as opposed to a person leaning in a given direction. It does this by filtering accelerometer samples by their x value
By default only samples with an x value >= 975 are accepted, this can be configured with the variable FILTER_THRESHOLD
The reasoning is that when a person wearing an accelerometer leans, the x value goes down, so by filtering samples
where that has happened we can isolate information generated by walking
"""

"""
Author's Note:
Frankly, this approach doesn't seem like it works. I may try and refine it further, but as it stands there hasn't been
anything very promising, and since I don't have much time left on this project, I will probably abandon it for an alternative approach.
I'll leave this code in the repository for posterity's sake, 
and for the possibility that the idea could inspire a better, similar approach in the future. 
"""


FILTER_THRESHOLD = 990 #acceleromter samples where x axis < FILTER_THRESHOLD are filtered out
SENSITIVITY_CAP = 200 #this is what is considered the "max" for axis scaling. lowering it makes the robot more sensitive

class AccelConversionNode(Node):
    def __init__(self):
        super().__init__('accel_conversion_node')
        self.subscriber = self.create_subscription(
            Accelerometer, 'biosensors/polar_h10/ACC_DATA', self.subscribe_callback, 100
            )

        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)
        self.last_message = Accelerometer(x=1000, y=0, z=0) #default of 1000mg (1G) on x, 0 on y and z (this is "stationary")
        self.last_twist = Twist()

    def subscribe_callback(self, accel_data):
        """
        y_difference = accel_data.y - self.last_message.y
        z_difference = accel_data.z - self.last_message.z
        """

        #filter out samples that are 'non-upright'
        if accel_data.x < FILTER_THRESHOLD:
            """
            I'm torn on whether or not issuing a halt command on receiving a sample that gets filtered is the right move
            Feel free to comment out the below publishing line as you see fit
            """
            self.publisher.publish(Twist())
            print('filtered')
            pass
        
        else:
            to_publish = Twist()

            if accel_data.z > 0:
                to_publish.linear.x = 0.26 * abs(accel_data.z / SENSITIVITY_CAP)
            elif accel_data.z < 0:
                to_publish.linear.x = -0.26 * abs(accel_data.z / SENSITIVITY_CAP)
            else:
                to_publish.linear.x = 0.0


            if accel_data.y < 0:
                to_publish.angular.z = 1.82 * abs(accel_data.y / SENSITIVITY_CAP)
            elif accel_data.y > 0:
                to_publish.angular.z = -1.82 * abs(accel_data.y / SENSITIVITY_CAP)
            else:
                to_publish.angular.z = 0.0

            #if to_publish.linear.x != self.last_twist.linear.x:
            self.last_twist = to_publish
            print(f'publishing: {to_publish}')
            for i in range (0, 10):
                self.publisher.publish(to_publish)
                sleep(0.1)



        

        
if __name__ == '__main__':
    rclpy.init()
    converter = AccelConversionNode()
    rclpy.spin(converter)
